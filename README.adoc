= DevOps workflow
Thomas SCHWENDER <icon:github[] https://github.com/Ardemius/[GitHub] / icon:twitter[role="aqua"] https://twitter.com/thomasschwender[@thomasschwender]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
:highlightjs-languages: asciidoc
// We must enable experimental attribute to display Keyboard, button, and menu macros
:experimental:
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 4
// To number the sections of the table of contents
//:sectnums:
// Add an anchor with hyperlink before the section title
:sectanchors:
// To turn off figure caption labels and numbers
:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
// :caption:

toc::[]

Ma repr√©sentation d'un *worflow DevOps complet* sous forme de sch√©ma, avec la *description de ses phases*.

== Sch√©ma d'un workflow DevOps et de ses phases

image::DevOps%20AceTP.png[title="DevOps Workflow"]

{nbsp} +
R√©alis√© int√©gralement avec https://inkscape.org/en/[Inkscape]. +
Sous licence https://en.wikipedia.org/wiki/Creative_Commons_license[Creative Commons *BY*] image:https://upload.wikimedia.org/wikipedia/commons/3/3c/Cc-by_new.svg[CC BY, 25, 25]

[TIP] 
====
* Les fichiers *PNG* and *SVG* du sch√©ma sont disponibles dans le r√©pertoire _images_ du repo üòâ 
* Mes *notes de recherche* sur les phases sont dans le fichier link:devops-workflow_notes.adoc[]
====

== Continuous "Everything"

Cette section a pour objectif d'expliquer de quoi il est question quand on parle de "Continuous Integration", "Continuous Delivery", "Continuous Deployment" et de CI/CD.

* *Continuous Integration* (*CI*) : +
L'Int√©gration Continue s'aligne avec les phases *CODE*, *BUILD* et *TEST* du pr√©c√©dent sch√©ma.
{lb}
Cette pratique consiste en l'*int√©gration r√©guli√®re* par les d√©veloppeurs des modifications de leur code source dans un *gestionnaire de code centralis√©*, et en *l'automatisation de la conduite de tests* visant √† d√©tecter l'introduction de r√©gressions dans le code. 

* *Continuous Delivery* (*CD*) : +
La Livraison Continue *compl√®te l'Int√©gration Continue* √† laquelle elle ajoute les phases *RELEASE* et *DEPLOY* du pr√©c√©dent sch√©ma. +
Une pr√©cision importante cependant : dans le cas de la Livraison Continue, le *d√©ploiement*, associ√© √† la phase DEPLOY, est le r√©sultat d'une *action manuelle* et NON d'une ex√©cution automatique.
{lb}
En plus des objectifs de la CI, la Livraison Continue rajoute les objectifs suivants : 
    ** *L'automatisation de la cr√©ation des livrables* de l'application
    ** *L'automatisation du d√©ploiement et de la configuration de ces livrables dans les diff√©rents environnements de qualification* (par exemple environnements d'int√©gration, de recette, de pre-prod) √† l'exception de la production qui n√©cessite une approbation manuelle
    ** *L'automatisation de la conduite de tests* dans les diff√©rents environnements o√π les livrables ont √©t√© d√©ploy√©s. +
    Les livrables ne pouvant √™tre "promus" dans un environnement sup√©rieur qu'√† partir du moment o√π ils ont valid√© les tests de l'environnement pr√©sent. +
    Exemple : les livrables doivent valider les tests sp√©cifiques √† l'environnement d'int√©gration avant d'√™tre promus (d√©ploy√©s) en environnement de recette.

* *Continuous Deployment* (de nouveau "*CD*", comme pour le Continous Delivery) : +
*D√©ploiement Continu et Livraison Continue sont similaires* √† la seule diff√©rence que la Livraison Continue n√©cessite une action manuelle pour le d√©ploiement des livrables en environnement de production (ce qui correspond √† la v√©ritable "MEP / Mise En Production" de l'application), alors que le D√©ploiement Continu r√©alise la mise en production automatiquement.

.Continous Integration, Delivery and Deployment (https://aws.amazon.com/fr/devops/continuous-delivery/)
image:continuous-integration-delivery-deployment.png[]

* *CI/CD* : +
L'expression "CI/CD" d√©signe simplement la combinaison de 2 ou 3 des pratiques pr√©c√©dentes : 
** Continuous Integration (CI) et Continuous Delivery (CD)
** Continuous Integration (CI) et Continuous Delivery (CD) et Continous Deployment (CD)
{lb}
On parlera souvent de "*cha√Æne de CI/CD*" pour d√©signer l'ensemble d'outils et le workflow d'√©tapes permettant d'impl√©menter les pratiques de CI et CD.

* *DevOps* : +
Le DevOps, contraction de *Dev* pour Development (D√©veloppement) et *Ops* pour Operations (Exploitation), d√©signe √† la fois un ensemble de pratiques (auxquelles appartiennent celles pr√©c√©demment d√©crites) et d'outils et une philosophie / culture de travail.
{lb}
Son but est d'am√©liorer la capacit√© d'une entreprise √† *livrer rapidement* des applications et services, de *garantir leur qualit√©*, de *faciliter leur √©volution* afin au final de *gagner en comp√©titivit√©*.
{lb}
On pourra parler aussi bien de "pratiques DevOps" que de "mouvement DevOps", d'"approche DevOps", ou encore de "cycle (de vie) DevOps" ou autre "pipeline" et "workflow" DevOps.

== Description des phases

=== PLAN

La phase de planification / conception concerne tout ce qui a lieu AVANT que l'√©quipe de d√©veloppement ne d√©bute l'√©criture du code. +
C'est le moment o√π l'on va construire la roadmap produit afin de guider les d√©veloppements √† venir.

Cette roadmap est g√©n√©ralement enregistr√©e et suivie √† l'aide d'un *outil de gestion de projet* comme Jira, Trello, Azure DevOps (fonctionnalit√© "Boards"), etc.

=== CODE

C'est durant cette phase que l'√©quipe de d√©veloppement impl√©mente les stories de la roadmap produit, et donc "√©crit le code".

Pour ce faire, les d√©veloppeurs utilisent un ensemble d'*outils* (IDE et leurs plugins, outil de mod√©lisation, utilitaires divers, etc.), *langages de d√©veloppement* (Java, Python, etc.), *frameworks* (Spring, Hibernate, etc.), *librairies* (Guava, Apache Commons, etc.) et *sp√©cifications* (JAX-RS, CDI, JSON-P, etc.), pour certains *d√©finis au niveau de l'organisation*, pour d'autres *sp√©cifiques au projet*.

Une fois √©crit, le code doit √™tre sauvegard√© et partag√© dans l'√©quipe √† l'aide de solutions d'h√©bergement de code (*Source Code Repository Manager*) s'appuyant sur un logiciel de *SCM* (*Source Code Management*). +
*Git* est actuellement le SCM le plus utilis√© au monde, et parmi les repo manager populaires s'appuyant dessus nous trouvons aujourd'hui GitHub, GitLab, Bitbucket pour ne citer qu'eux.

==== Strat√©gie de branching Git

2 types de strat√©gies de gestion de branches ("branching strategies") sont globalement utilis√©es aujourd'hui (2022) sur le march√© :

    * Les workflows dits de "*feature branching*" auxquels appartiennent Git Flow, GitHub flow et GitLab flow.
    {lb}
    image:git-branching-strategies_feature-branching.png[width=800]

    * Les workflow dits "*trunk-based*" (on parlera de "trunk-based development")
    {lb}
    image:git-branching-strategies_trunk-based.png[width=600]

[.small]#Source des 2 pr√©c√©dents sch√©mas : https://learn.microsoft.com/fr-fr/archive/blogs/technet/devops/a-git-workflow-for-continuous-delivery#

[NOTE]
====
Depuis quelques ann√©es maintenant, le *trunk-based development* est redevenu la *strat√©gie de branching la plus utilis√©e*, devant le feature branching qui avait pris le lead lors de l'adoption massive des outils de type DVCS (bas√©s sur Git). +
-> C'est principalement la cons√©quence des *difficult√©s de merge* rencontr√©es avec le *feature branching* du fait du grand nombre de branches manipul√©es ("feature branches hell")
====

=== BUILD

La phase de BUILD est celle o√π le code source va √™tre r√©cup√©r√© (du pr√©c√©dent repo manager) puis build√© afin de pouvoir √™tre test√©.

Le r√©sultat du build, souvent appel√© "*archive*" (JAR pour Java ARchive, WAR pour Web ARchive, etc.), a pour vocation d'√™tre ensuite d√©ploy√©, test√© et valid√© dans les diff√©rents environnements du projet (par exemple DEVELOPPEMENT, INTEGRATION, RECETTE, PRE-PRODUCTION et finalement PRODUCTION).

[NOTE]
====
Il est √† noter que l'on devrait toujours *ne builder qu'une unique fois* une archive, puis d√©ployer et tester progressivement cette m√™me archive dans les diff√©rents environnements et NON builder une archive sp√©cifique par environnement.
====

La *cr√©ation de l'archive* √† partir du code source est r√©alis√©e √† l'aide d'un *outil de build*. +
Parmi les plus connus on retrouve Maven, Gradle, Ant, NPM, etc.

Le *d√©clenchement du build* est g√©n√©ralement r√©alis√© par un outil d'automatisation, de type *serveur d'int√©gration continue*. +
L'√©l√©ment d√©clencheur du build ("trigger") est soit une action manuelle, soit la d√©tection en temps presque r√©el d'une modification du code dans le repo manager (pr√©sence d'un nouveau commit modifiant le code). +
Les serveurs d'int√©gration d√©l√®gue ensuite la cr√©ation de l'archive aux outils de build vus pr√©c√©demment.
Parmi les serveurs d'int√©gration continue les plus connus on retrouve Jenkins, Travis CI, GitLab CI, Azure DevOps, etc.

.Exemple de workflow avec Jenkins
image:jenkins-workflow-example.jpg[]

=== TEST

Une fois build√©s, les archives sont d√©ploy√©s dans un environnement de qualification o√π plusieurs s√©ries de tests, manuels (UAT ou tests de recette) et / ou automatiques (tests d'int√©gration, d'API, de s√©curit√©, etc.) sont d√©roul√©s. +
Les archives peuvent √©galement √™tre d√©ploy√©es dans plusieurs environnements de qualification, chacun √©tant l'objet de tests de natures diff√©rentes.

=== RELEASE

La phase de release est celle o√π le *livrable de production* (certains outils parleront de "package" ou "deployment package") va √™tre cr√©√© en combinant les archives pr√©c√©demment build√©es et test√©es avec les diff√©rents param√®tres permettant de les d√©dier √† l'environnement cibl√© (package = archives + fichiers de param√©trage).

Le livrable de production / package ainsi cr√©√© sera ensuite stock√© dans un *r√©f√©rentiel sp√©cifique*. 
Suivant la nature du livrable, ce r√©f√©rentiel pourra √™tre soit un *repository manager* (Nexus et Artifactory sont les plus utilis√©s), ou un outil d√©di√© (Digital.ai Deploy (anciennement XL Deploy) )

=== DEPLOY

La phase de DEPLOY correspond au d√©ploiement, √† l'installation du livrable de production de la phase RELEASE en environnement de PROD. +
Ce d√©ploiement peut √™tre soit manuel dans le cadre d'une approche *Continuous Delivery*, soit *automatique* dans le cadre du *Continuous Deployment*.

Les principaux outils permettant de configurer un environnement √† partir des √©l√©ments contenus dans le livrable de production sont appel√©s *outils d'automatisation et de gestion de configuration*, parmi lesquels on peut citer *Ansible*, *XL Deploy* (Digital.ai Deploy), *Terraform*. +
Ces outils permettent d'automatiser totalement la proc√©dure de d√©ploiement qui est d√©crite sous forme de fichier (descripteur de d√©ploiement), on parlera d'*Infrastructure-as-Code* (*IaC*)

Et, plut√¥t que de d√©ployer un livrable sur un serveur physique, les *solutions de virtualisation et conteneurisation* sont pl√©biscit√©es. +
Ces derni√®res, conjugu√©es √† l'Infrastructure-as-Code, permettent une meilleure agilit√© et scalabilit√© (capacit√© √† d√©truire, recr√©er et ajouter au besoin un ou plusieurs runtime / environnements), des caract√©ristiques tr√®s demand√©es pour les architectures Cloud et microservices qui multiplient le nombre de serveurs et services. +
Parmi les solutions de virtualisation et de conteneurisation les plus connues : toutes les stacks Cloud actuelles, Docker, Podman, Kubernetes, OpenShift, etc.

=== OPERATE

A ce stade, l'application est d√©ploy√©e en PROD et est en cours de fonctionnement. +
La phase OPERATE regroupe toutes les op√©rations visant √† assurer le bon fonctionnement de l'application. +
On y retrouve : 

    * La mise en place de moyens de *d√©tection de tout comportement anormal* de l'application (*monitoring*), devant donner lieu √† la g√©n√©ration d'une *alerte* (*alerting*). +
    Ces alertes seront stock√©es dans un outil de *gestion de tickets* (Issue Tracking System, ITS).
    {lb}
    Exemples de comportement anormal de l'application : rupture de SLA, serveur down, absence de r√©ponse d'un service, etc.

    * Toutes les *interventions de support*, manuelle ou automatique (script ou autre outil) ayant pour but de corriger un probl√®me afin de revenir √† un comportement normal de l'application.

Parmi les solutions ITS les plus connues : JIRA, ServiceNow, Mantis

.Diff√©rences entre monitoring et alerting
[NOTE]
====
Le *monitoring* est le processus par lequel on maintient la surveillance sur l'√©tat d'un syst√®me. +
Un syst√®me *dit de monitoring* repr√©sente un ensemble d'outils permettant la collecte, le traitement et la visualisation (dashboard, indicateurs visuels, etc.) de donn√©es de t√©l√©m√©trie.

Le monitoring peut √™tre soit :

    * *Proactive* : il est n√©cessaire de consulter r√©guli√®rement les outils de visualisation du monitoring pour se tenir au courant de l'√©tat du syst√®me
    
    * *R√©actif* : c'est le syst√®me de monitoring qui informera automatiquement d'un changement pr√©d√©fini de l'√©tat du syst√®me, via l'envoi de notification ou d'alerte. +
    On parlera d'*alerting*. 

-> L'*alerting* correspond donc √† la capacit√© d'un syst√®me de monitoring de *d√©tecter un changement d'√©tat* donn√© et d'en *notifier* l'√©quipe d'exploitation.
====

Les syst√®mes de monitoring sont souvent regroup√©s en sous-cat√©gories suivant leur sp√©cialit√©.
Voici quelques exemples : 

    * les APM (Application Performance Management) : Dynatrace et Datadog
    * logiciel de supervision : Centreon, Sentry, Nagios
    * Prometheus pour le monitoring de Kubernetes
    * La stack ELK (collecte de donn√©es avec Logstash, requ√™tage avec Elasticsearch et dashboarding avec Kibana)
    * *OpenTelemetry* devient de plus en plus la norme pour l'*envoi* et la *collecte de donn√©es* de t√©l√©m√©trie

=== FEEDBACK & MONITORING

L'id√©e de cette phase de "feedback & monitoring" est que l'analyse des donn√©es de t√©l√©m√©trie doit permettre de mieux *comprendre l'application* afin d'√™tre capable d'*anticiper*, de *pr√©dire* son comportement futur, afin de pr√©venir d'√©ventuels probl√®mes d'arriver.

Les outils utilis√©s sont *les m√™mes syst√®mes de monitoring que pour la phase Operate*, mais plut√¥t qu'√™tre utilis√©s pour de l'alerting (c'est-√†-dire notifier d'un probl√®me / incident via l'envoi d'une alerte), ils vont servir √† observer l'√©volution de l'√©tat de l'application afin de nous donner la capacit√© d'entreprendre des actions visant √† pr√©venir tout futur probl√®me. +
Ces actions seront donc r√©alis√©es *AVANT* qu'un probl√®me, et donc une alerte, ne soit remont√©.

Cette observation de l'√©volution de l'√©tat de l'application devant √™tre r√©alis√©e sur un p√©riode de temps et non un instant "t", elle implique souvent l'utilisation de *timeseries* (s√©ries temporelles).

Le *feedback* implique √©galement l'observation de l'efficacit√© des actions correctives d√©j√† men√©es : ces derni√®res ont-elles √©t√© efficaces ? P√©rennes ? Workaround avant une solution durable ?


