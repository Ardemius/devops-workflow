= DevOps workflow
Thomas SCHWENDER <icon:github[] https://github.com/Ardemius/[GitHub] / icon:twitter[role="aqua"] https://twitter.com/thomasschwender[@thomasschwender]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
:highlightjs-languages: asciidoc
// We must enable experimental attribute to display Keyboard, button, and menu macros
:experimental:
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 4
// To number the sections of the table of contents
//:sectnums:
// Add an anchor with hyperlink before the section title
:sectanchors:
// To turn off figure caption labels and numbers
:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
// :caption:

toc::[]

Ma repr√©sentation d'un *worflow DevOps complet* sous forme de sch√©ma, avec la *description de ses phases*.

== Sch√©ma d'un workflow DevOps et de ses phases

image::DevOps%20AceTP.png[title="DevOps Workflow"]

{nbsp} +
R√©alis√© int√©gralement avec https://inkscape.org/en/[Inkscape]. +
Sous licence https://en.wikipedia.org/wiki/Creative_Commons_license[Creative Commons *BY*] image:https://upload.wikimedia.org/wikipedia/commons/3/3c/Cc-by_new.svg[CC BY, 25, 25]

[TIP] 
====
* Les fichiers *PNG* and *SVG* du sch√©ma sont disponibles dans le r√©pertoire _images_ du repo üòâ 
* Mes *notes de recherche* sur les phases sont dans le fichier link:devops-workflow_notes.adoc[]
====

== Description des phases

=== Continuous "Everything"

Cette section a pour objectif d'expliquer de quoi il est question quand on parle de "Continuous Integration", "Continuous Delivery", "Continuous Deployment" et de CI/CD.

* *Continuous Integration* (*CI*) : +
L'Int√©gration Continue s'aligne avec les phases *CODE*, *BUILD* et *TEST* du pr√©c√©dent sch√©ma.
{lb}
Cette pratique consiste en l'*int√©gration r√©guli√®re* par les d√©veloppeurs des modifications de leur code source dans un *gestionnaire de code centralis√©*, et en *l'automatisation de la conduite de tests* visant √† d√©tecter l'introduction de r√©gressions dans le code. 

* *Continuous Delivery* (*CD*) : +
La Livraison Continue *compl√®te l'Int√©gration Continue* √† laquelle elle ajoute les phases *RELEASE* et *DEPLOY* du pr√©c√©dent sch√©ma. +
Une pr√©cision importante cependant : dans le cas de la Livraison Continue, le *d√©ploiement*, associ√© √† la phase DEPLOY, est le r√©sultat d'une *action manuelle* et NON d'une ex√©cution automatique.
{lb}
En plus des objectifs de la CI, la Livraison Continue rajoute les objectifs suivants : 
    ** *L'automatisation de la cr√©ation des livrables* de l'application
    ** *L'automatisation du d√©ploiement et de la configuration de ces livrables dans les diff√©rents environnements de qualification* (par exemple environnements d'int√©gration, de recette, de pre-prod) √† l'exception de la production qui n√©cessite une approbation manuelle
    ** *L'automatisation de la conduite de tests* dans les diff√©rents environnements o√π les livrables ont √©t√© d√©ploy√©s. +
    Les livrables ne pouvant √™tre "promus" dans un environnement sup√©rieur qu'√† partir du moment o√π ils ont valid√© les tests de l'environnement pr√©sent. +
    Exemple : les livrables doivent valider les tests sp√©cifiques √† l'environnement d'int√©gration avant d'√™tre promus (d√©ploy√©s) en environnement de recette.

* *Continuous Deployment* (de nouveau "*CD*", comme pour le Continous Delivery) : +
*D√©ploiement Continu et Livraison Continue sont similaires* √† la seule diff√©rence que la Livraison Continue n√©cessite une action manuelle pour le d√©ploiement des livrables en environnement de production (ce qui correspond √† la v√©ritable "MEP / Mise En Production" de l'application), alors que le D√©ploiement Continu r√©alise la mise en production automatiquement.

.Continous Integration, Delivery and Deployment (https://aws.amazon.com/fr/devops/continuous-delivery/)
image:continuous-integration-delivery-deployment.png[]

* *CI/CD* : +
L'expression "CI/CD" d√©signe simplement la combinaison de 2 ou 3 des pratiques pr√©c√©dentes : 
** Continuous Integration (CI) et Continuous Delivery (CD)
** Continuous Integration (CI) et Continuous Delivery (CD) et Continous Deployment (CD)
{lb}
On parlera souvent de "*cha√Æne de CI/CD*" pour d√©signer l'ensemble d'outils et le workflow d'√©tapes permettant d'impl√©menter les pratiques de CI et CD.

* *DevOps* : +
Le DevOps, contraction de *Dev* pour Development (D√©veloppement) et *Ops* pour Operations (Exploitation), d√©signe √† la fois un ensemble de pratiques (auxquelles appartiennent celles pr√©c√©demment d√©crites) et d'outils et une philosophie / culture de travail.
{lb}
Son but est d'am√©liorer la capacit√© d'une entreprise √† *livrer rapidement* des applications et services, de *garantir leur qualit√©*, de *faciliter leur √©volution* afin au final de *gagner en comp√©titivit√©*.
{lb}
On pourra parler aussi bien de "pratiques DevOps" que de "mouvement DevOps", d'"approche DevOps", ou encore de "cycle (de vie) DevOps" ou autre "pipeline" et "workflow" DevOps.


=== PLAN

La phase de planification / conception concerne tout ce qui a lieu AVANT que l'√©quipe de d√©veloppement ne d√©bute l'√©criture du code. +
C'est le moment o√π l'on va construire la roadmap produit afin de guider les d√©veloppements √† venir.

Cette roadmap est g√©n√©ralement enregistr√©e et suivie √† l'aide d'un *outil de gestion de projet* comme Jira, Trello, Azure DevOps (fonctionnalit√© "Boards"), etc.

=== CODE

C'est durant cette phase que l'√©quipe de d√©veloppement impl√©mente les stories de la roadmap produit, et donc "√©crit le code".

Pour ce faire, les d√©veloppeurs utilisent un ensemble d'outils (IDE et leurs plugins, outil de mod√©lisation, utilitaires divers, etc.), langages de d√©veloppement (Java, Python, etc.), frameworks (Spring, Hibernate, etc.), librairies (Guava, Apache Commons, etc.) et sp√©cifications (JAX-RS, CDI, JSON-P, etc.), pour certains d√©finis au niveau de l'organisation, pour d'autres sp√©cifiques au projet.

Une fois √©crit, le code doit √™tre sauvegard√© et partag√© dans l'√©quipe √† l'aide de solutions d'h√©bergement de code (*Source Code Repository Manager*) s'appuyant sur un logiciel de *SCM* (*Source Code Management*). +
*Git* est actuellement le SCM le plus utilis√© au monde, et parmi les repo manager populaires s'appuyant dessus nous trouvons aujourd'hui GitHub, GitLab, Bitbucket pour ne citer qu'eux.

==== Ressources 

* *Git branching strategy* : 
    ** feature branching (Gitflow, GitHub flow ou GitLab flow) vs trunk-based development : 
        *** https://dzone.com/articles/why-i-prefer-trunk-based-development-over-feature
        *** 2022 : https://nira.com/git-branching-strategies-vs-trunk-based-development/ 
        *** https://hitesh-pattanayak.medium.com/git-flow-development-vs-trunk-based-debelopment-923ce4553043
            **** je cite cet article avant tout pour son bon sch√©ma de comparaison des 2 strat√©gies (simple et efficace)
            **** en fait, on retrouve ces sch√©mas dans cet article de Medium (2018) : +
            https://medium.com/safetycultureengineering/trunks-are-not-just-for-trees-from-git-flow-to-trunk-based-development-949d580697ef
            **** tr√®s tr√®s bon REX du Git flow, de ses √©cueils, et des raisons du retour au trunk-based development
        *** https://dzone.com/articles/why-i-prefer-trunk-based-development-over-feature
            **** bon (vieux) sch√©ma du trunk-based development

    ** Depuis quelques ann√©es maintenant, le *trunk-based development* est redevenu la strat√©gie de branching la plus utilis√©e, devant le feature branching qui avait pris le lead lors de l'adoption massive des outils de type DVCS (bas√©s sur Git).
        *** Principalement du fait de difficult√©s de merge rencontr√©es avec le feature branching du fait du grand nombre de branches manipul√©es ("feature branches hell")

=== BUILD

La phase de BUILD est celle o√π le code source va √™tre r√©cup√©r√© (du pr√©c√©dent repo manager) puis build√© afin de pouvoir √™tre test√©.

Le r√©sultat du build, souvent appel√© "archive" (JAR pour Java ARchive, WAR pour Web ARchive, etc.), a pour vocation d'√™tre ensuite d√©ploy√©, test√© et valid√© dans les diff√©rents environnements du projet (par exemple DEVELOPPEMENT, INTEGRATION, RECETTE, PRE-PRODUCTION et finalement PRODUCTION).

 	Il est √† noter que l'on devrait toujours ne builder qu'une unique fois une archive, puis d√©ployer et tester progressivement cette m√™me archive dans les diff√©rents environnements et NON builder une archive sp√©cifique par environnement

La cr√©ation de l'archive √† partir du code source est r√©alis√©e √† l'aide d'un outil de build.
Parmi les plus connus on retrouve Maven, Gradle, Ant, NPM, etc.

Le d√©clenchement du build est g√©n√©ralement r√©alis√© par un outil d'automatisation, de type serveur d'int√©gration continue. 
L'√©l√©ment d√©clencheur du build ("trigger") est soit une action manuelle, soit la d√©tection en temps presque r√©el d'une modification du code dans le repo manager (pr√©sence d'un nouveau commit modifiant le code).
Les serveurs d'int√©gration d√©l√®gue ensuite la cr√©ation de l'archive aux outils de build vus pr√©c√©demment.
Parmi les serveurs d'int√©gration continue les plus connus on retrouve Jenkins, Travis CI, GitLab CI, Azure DevOps, etc.

* Rappel sur quelques formats d'archive : 
    ** https://objis.com/comprendre-les-livraisons-j2ee-war-jars-rar-ear/
    ** https://www.theserverside.com/feature/What-are-the-differences-between-EAR-JAR-and-WAR-files

* alternatives √† Jenkins en 2022 : 
    ** https://www.capterra.fr/alternatives/171026/jenkins
    ** Travis CI, CircleCI, TeamCity, etc.
* Pour une d√©finion de Jenkins mentionnant le concept de "automation", voir : +
https://www.techtarget.com/searchsoftwarequality/definition/Jenkins
    ** Jenkins est consid√©r√© comme une automation platform, un serveur d'int√©gration continue, un scheduler et peu √©galement √™tre utilis√© comme ordonnanceur en le "tordant un peu"
        *** Pour un v√©ritable ordonnanceur, partir plut√¥t sur une solution de type Autosys, ou Control-M.
        *** Pour ces derniers outils, on parlera davantage d'*orchestration* du flux de travail (il est souvent question de "workload automation", on pourra √©galement parler d'orchestrateur de workflow): +
        "Control‚ÄëM simplifies and automates diverse *batch application workloads* while reducing failure rates, improving SLAs, and accelerating application deployment."
* Pour un exemple de workflow Jenkins : 
    ** https://www.jenkins.io/pipeline/getting-started-pipelines/
    ** https://www.jenkins.io/doc/book/pipeline/
    ** tr√®s bon sch√©ma, classique et clair, en 7:47 dans cette vid√©o : +
    https://youtu.be/8lGoul8KUdQ?t=467[Understanding DevOps using Jenkins, Maven, Nexus Artifactory and Ansible]
* Cas d'usage de Jenkins pour des workflows allant jusqu'√† la production : 
    ** https://medium.com/@maxy_ermayank/pipeline-as-a-code-using-jenkins-2-aa872c6ecdce

* Alternatives √† Maven et autres build tools : 
    ** https://alternativeto.net/software/gradle/
    ** Maven, Gradle, Ant, SBT
    ** NPM pour Node.js
        *** voir https://devstory.net/11925/qu-est-ce-que-npm

=== TEST

----
Une fois build√©s, les archives sont d√©ploy√©s dans un environnement de qualification o√π plusieurs s√©ries de tests, manuels (UAT ou tests de recette) et / ou automatiques (tests d'int√©gration, d'API, de s√©curit√©, etc.) sont d√©roul√©s.
Les archives peuvent √©galement √™tre d√©ploy√©es dans plusieurs environnements de qualification, chacun √©tant l'objet de tests de natures diff√©rentes.
----

* Pyramide des tests : https://latavernedutesteur.fr/2022/02/07/pourquoi-une-pyramide-pour-les-tests/

=== RELEASE

----
La phase de release est celle o√π le livrable de production (certains outils parleront de "package" ou "deployment package") va √™tre cr√©√© en combinant les archives pr√©c√©demment build√©es et test√©es avec les diff√©rents param√®tres permettant de les d√©dier √† l'environnement cibl√© (package = archives + fichiers de param√©trage).

Le livrable de production / package ainsi cr√©√© sera ensuite stock√© dans un r√©f√©rentiel sp√©cifique. 
Suivant la nature du livrable, ce r√©f√©rentiel pourra √™tre soit un repository manager (Nexus et Artifactory sont les plus utilis√©s), ou outil d√©di√© (XL Deploy (maintenant Digital.ai Deploy)
----

* semantic versioning pour les release
    ** https://code-garage.fr/blog/qu-est-ce-que-le-semantic-versioning/

Pour l'acc√®s au Nexus, faire une demande Jira ou peut-√™tre demander √† Hamdi

=== DEPLOY

----
La phase de DEPLOY correspond au d√©ploiement, √† l'installation du livrable de production de la phase RELEASE en environnement de PROD.
Ce d√©ploiement peut √™tre soit manuel dans le cadre d'une approche Continuous Delivery, soit automatique dans le cadre du Continuous Deployment.

Les principaux outils permettant de configurer un environnement √† partir des √©l√©ments contenus dans le livrable de production sont appel√©s outils d'automatisation et de gestion de configuration, parmi lesquels on peut citer Ansible, XL Deploy (Digital.ai Deploy), Terraform.
Ces outils permettent d'automatiser totalement la proc√©dure de d√©ploiement qui est d√©crite sous forme de fichier (descripteur de d√©ploiement), on parlera d'Infrastructure-as-Code (IaC)

Et, plut√¥t que de d√©ployer un livrable sur un serveur physique, les solutions de virtualisation et conteneurisation sont pl√©biscit√©es.
Ces derni√®res, conjugu√©es √† l'Infrastrucuture-as-Code, permettent une meilleure agilit√© et scalabilit√© (capacit√© √† d√©truire, recr√©er et ajouter au besoin un ou plusieurs runtime / environnements), des caract√©ristiques tr√®s demand√©es pour les architectures Cloud et microservices qui multiplient le nombre de serveurs et services.
Parmi les solutions de virtualisation et de conteneurisation les plus connues : toutes les stacks Cloud actuelles, Docker, Podman, Kubernetes, OpenShift, etc.
----

* D√©finition claire du but d'Ansible : https://blog.stephane-robert.info/post/introduction-ansible/
* Pour les autres outils d'automatisation et gestion de configuration les plus utilis√©s en 2022, voir https://www.servertribe.com/top-5-ansible-alternatives/
    ** En gros, Terraform, Puppet, Chef

=== OPERATE

* outils d'alerting les plus utilis√©s en 2022 : https://www.g2.com/categories/it-alerting
+
--
*IT alerting software* delivers notifications for *IT systems failures*. These tools will monitor systems for poor performance, infrastructure issues, and other IT management issues. These notifications may be delivered via email, SMS, or other means of communication. Companies use these tools to identify issues within their networks, IT infrastructure, and other IT systems to reduce downtime and prevent potential permanent damage.
--

* Tr√®s bon article sur OpenTelemetry, l'observabilit√©, les logs / m√©triques / traces : 
https://www.splunk.com/fr_fr/data-insider/what-is-opentelemetry.html
    ** OpenTelemetry : OpenTelemetry sera √† terme le cadre d'observabilit√© dominant dans le paysage de t√©l√©m√©trie natif du cloud.

* Prometheus : https://prometheus.io/docs/introduction/overview/
    ** "Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud."
    ** "Prometheus collects and stores its metrics as time series data, i.e. metrics information is stored with the timestamp at which it was recorded, alongside optional key-value pairs called labels."

* Definition of *alerting and monitoring* : https://www.oreilly.com/library/view/effective-monitoring-and/9781449333515/ch01.html (TRES BON)
    ** contient √©galement une bonne d√©finition d'un *monitoring system* : +
    "A set of software components used for data collection, their processing, and presentation is called a monitoring system.""
    
    ** Diff√©rence entre monitoring et alerting : 

        *** *MONITORING* (proactive monitoring) : +
        "The former involves watching visual indicators, such as timeseries and dashboards, and is sometimes what administrators mean by monitoring." +
        "Monitoring is the *process of maintaining surveillance over the existence and magnitude of state change* and data flow in a system. Monitoring aims to identify faults and assist in their subsequent elimination. The techniques used in monitoring of information systems intersect the fields of real-time processing, statistics, and data analysis. A set of software components used for data collection, their processing, and presentation is called a *monitoring system*."

        *** *ALERTING* (reactive monitoring) : +
        "involves automated ways to deliver notifications to operators in order to bring to their attention a grave change in system's state; this is usually referred to as alerting." +
        "Alerting is the *capability of a monitoring system to detect and notify the operators about meaningful events that denote a grave change of state*. The notification is referred to as an alert and is a simple message that may take multiple forms: email, SMS, instant message (IM), or a phone call. The alert is passed on to the appropriate recipient, that is, a party responsible for dealing with the event. The alert is often logged in the form of a ticket in an *Issue Tracking System* (ITS), also referred to simply as *ticketing system*."

            **** Definition of an *alert* : +
            "An alert is a *notification of a potential problem*, which can take one or more of the following forms: email, SMS, phone call, or a ticket. An alert is issued by an alarm when the system transitions through some threshold, and this threshold breach is detected by a monitor. Thus, for example, you may configure an alarm to alert you when the system exceeds 80% of CPU utilization for a continuous period of 10 minutes." +
            "A notification message informing about a change of state, typically signifying a potential problem."

    ** On ne peut PAS avoir d'alerting sans monitoring

* Pour les ITS et outils de ticketing (bug reporting) : https://teambrain.fr/optimisez-votre-ticketing/
    ** JIRA, ServiceNow, Mantis, etc.

* Les syst√®mes de monitoring sont souvent regroup√©s en sous-cat√©gories suivant leur sp√©cialit√©. +
Voici quelques exemples : 
    ** les APM (Application Performance Management) : Dynatrace et Datadog
        *** https://www.g2.com/categories/it-alerting
    ** logiciel de supervision : Centreon, Sentry, Nagios
        *** voir https://www.lemagit.fr/definition/Surveillance-IT-IT-monitoring
    ** Prometheus pour le monitoring de Kubernetes
        *** https://prometheus.io/docs/introduction/overview/
    ** OpenTelemetry devient de plus en plus la norme pour l'envoi et la collecte de donn√©es de t√©l√©m√©trie

* Syst√®mes de monitoring : 
    ** https://intellipaat.com/blog/devops-monitoring-tools/
    ** https://www.g2.com/categories/it-alerting

* Pour un exemple d'article qui met Centreon et Prometheus au m√™me niveau, en tant que "outils de monitoring", voir : https://stackshare.io/stackups/centreon-vs-prometheus

=== FEEDBACK & MONITORING

* Monitoring and alerting : https://www.oreilly.com/library/view/effective-monitoring-and/9781449333515/ch01.html
    ** Monitoring "refers to the process of becoming aware of the state of a system"
    ** il y est question de la "*Monitoring's feedback loop*" : +
    "Monitoring's feedback loop is also central to the idea of *Autonomic Computing* (AC), an architecture in which the system is capable of regulating itself and thus enabling self-management and self-healing. +
    AC was inspired by the operation of the human central nervous system. It draws an analogy between it and a complex, distributed information system. Unconscious processes, such as the control over the rate of breath, do not require human effort. The goal of AC is to minimize the need for human intervention in a similar way, by replacing it with self-regulation. Comprehensive monitoring can provide an effective means to achieve this end."
    ** le monitoring implique les *timeseries*

* Monitoring and observability : https://dzone.com/refcardz/getting-started-with-opentelemetry

* Observability : https://dzone.com/refcardz/full-stack-observability-essentials
    ** Observability is "the ability to understand the current state of a system using only its external outputs."
    ** l'article propose une diff√©rence entre observabilit√© et monitoring, et explique que l'observabilit√© est l√† pour augmenter le potentiel du monitoring

    ** "Monitoring is an action; a human or an automated process can do it if they know what signals to look for. It can generate alerts, provide insights, suggest actions, measure traffic or real-user activity, and warn when issues occur."
    ** "Observability, on the other hand, lets you understand why the problem occurred. It is an approach that enables teams to ask questions about the holistic state of a system."

Derri√®re cette notion de "feedback & monitoring", et m√™me d'observabilit√©, il y a l'objectif de mieux comprendre l'application afin d'√™tre capable d'anticiper, de pr√©dire, son comportement futur, et de pr√©venir d'eventuels probl√®mes d'arriver.

* Feedback : Besoin de remonter les cons√©quences d'une action corrective : retour √† la normale ou pas ?

== Schema resources

WARNING: I first designed this schema in 2017/02, and some of the below resources I used when creating it are available anymore.

* https://dzone.com/storage/assets/18140-Continuous-Delivery.pdf[DZone - The DZone guide to Continuous Delivery 2015]: p20/43
* https://dzone.com/storage/assets/17431-docker-jenkins-continuous-delivery.pdf[DZone - Docker / Jenkins - Continuous Delivery]: p15/18
* http://www.bogotobogo.com/DevOps/DevOps_CI_CD_Pipeline_Sample.php
* http://www.rightscale.com/blog/cloud-management-best-practices/continuous-integration-and-delivery-cloud-how-rightscale-does-it
* http://atginfo.com/demystifying-dev-ops-part-1/
* http://agilityladder.nl/it-value/continuous-delivery/: circular graph on Continuous Delivery

Ressources pour la description des phases du cycle DevOps : 

    * https://medium.com/taptuit/the-eight-phases-of-a-devops-pipeline-fda53ec9bba
        ** et pour la description des cycles Continuous Integration, Continuous Delivery, Continuous Deployment : +
        https://medium.com/taptuit/what-is-devops-fb3d044ef659
        
    * https://blog.hubspot.com/website/devops-pipeline

Explication de la Continuous Integration, Continuous Delivery et Continuous deployment

    * Continuous Integration : 
        ** https://aws.amazon.com/fr/devops/continuous-integration/
    * Continuous Delivery : 
        ** https://aws.amazon.com/fr/devops/continuous-delivery/
    * Continuous Deployment : 
        ** https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment
    * Wikipedia pour les 3
        ** https://en.wikipedia.org/wiki/Continuous_integration
        ** https://en.wikipedia.org/wiki/Continuous_delivery
        ** https://en.wikipedia.org/wiki/Continuous_deployment
    * https://www.redhat.com/fr/topics/devops/what-is-ci-cd
        ** pour la CI/CD, voir √©galement la d√©finition simple et efficace de https://fr.wikipedia.org/wiki/CI/CD

Explication sur le DevOps : 

    * https://medium.com/taptuit/what-is-devops-fb3d044ef659
    * https://www.atlassian.com/fr/devops
    * https://fr.wikipedia.org/wiki/Devops
    * https://aws.amazon.com/fr/devops/what-is-devops/
    * https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-devops/

